Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AND
    AND_ASSIGN
    BLOCK_COMMENT
    COMA
    CONCA
    CONCAT
    DOSCOMA
    EQUAL
    ESPACIO
    GREATTHANEQUAL
    LCORCHETE
    LESSTHANEQUAL
    LLLAVE
    NEQUAL
    NOT
    NULL
    OR
    OR_ASSIGN
    PUNTO
    RCORCHETE
    RLLAVE
    XOR
    XOR_ASSIGN

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration
Rule 2     program -> listdeclaration
Rule 3     program -> arraydeclaration
Rule 4     program -> linkedlistdeclaration
Rule 5     program -> doublelinkedlistdeclaration
Rule 6     program -> stackdeclaration
Rule 7     program -> queuedeclaration
Rule 8     Type -> INT
Rule 9     Type -> BOOLEAN
Rule 10    Type -> SHORT
Rule 11    Type -> FLOAT
Rule 12    Type -> LONG
Rule 13    Type -> DOUBLE
Rule 14    Type -> CHAR
Rule 15    Type -> BYTE
Rule 16    Type -> OBJECT
Rule 17    Typet -> INT
Rule 18    Typet -> BOOLEAN
Rule 19    Typet -> SHORT
Rule 20    Typet -> FLOAT
Rule 21    Typet -> LONG
Rule 22    Typet -> DOUBLE
Rule 23    Typet -> CHAR
Rule 24    Typet -> BYTE
Rule 25    Typet -> OBJECT
Rule 26    Typet -> empty
Rule 27    accessmodif -> PUBLIC
Rule 28    accessmodif -> PRIVATE
Rule 29    accessmodif -> PROTECTED
Rule 30    accessmodif -> DEFAULT
Rule 31    accessmodif -> empty
Rule 32    finalstatvar -> FINAL
Rule 33    finalstatvar -> STATIC
Rule 34    finalstatvar -> FINAL STATIC
Rule 35    finalstatvar -> empty
Rule 36    declaration -> accessmodif finalstatvar Type VAR endexpression
Rule 37    declaration -> accessmodif finalstatvar Type assign
Rule 38    listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression
Rule 39    listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression
Rule 40    listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN listassign
Rule 41    listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN listassign
Rule 42    listassign -> VAR EQUALS listexpression endexpression
Rule 43    listexpression -> NEW LIST LESSTHAN Typet GREATTHAN LPAREN RPAREN
Rule 44    arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression
Rule 45    arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression
Rule 46    arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign
Rule 47    arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign
Rule 48    arrayassign -> VAR EQUALS arrayexpression endexpression
Rule 49    arrayexpression -> NEW ARRAYLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN
Rule 50    linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
Rule 51    linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
Rule 52    linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign
Rule 53    linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign
Rule 54    linkedlistassign -> VAR EQUALS linkedlistexpression endexpression
Rule 55    linkedlistexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN
Rule 56    doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
Rule 57    doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
Rule 58    doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign
Rule 59    doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign
Rule 60    doublelinkedlistassign -> VAR EQUALS doublelinkedlistexpression endexpression
Rule 61    doublelinkedlistexpression -> NEW DOUBLELINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN
Rule 62    stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression
Rule 63    stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression
Rule 64    stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN stackassign
Rule 65    stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN stackassign
Rule 66    stackassign -> STRING EQUALS stackexpression endexpression
Rule 67    stackexpression -> NEW STACK LESSTHAN Typet GREATTHAN LPAREN RPAREN
Rule 68    queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression
Rule 69    queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression
Rule 70    queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign
Rule 71    queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign
Rule 72    queueassign -> VAR EQUALS queueexpression endexpression
Rule 73    queueexpression -> NEW QUEUE LESSTHAN Typet GREATTHAN LPAREN RPAREN
Rule 74    queueexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN
Rule 75    assign -> VAR EQUALS expression endexpression
Rule 76    endexpression -> PUNTOCOMA
Rule 77    expression -> expression PLUS expression
Rule 78    expression -> expression MINUS expression
Rule 79    expression -> expression TIMES expression
Rule 80    expression -> expression DIVIDE expression
Rule 81    expression -> expression MOD expression
Rule 82    expression -> PLUSPLUS
Rule 83    expression -> MINUSMINUS
Rule 84    expression -> expression TIMESTIMES expression
Rule 85    expression -> TIMES_ASSIGN expression
Rule 86    expression -> MINUS_ASSIGN expression
Rule 87    expression -> PLUS_ASSIGN expression
Rule 88    expression -> DIVIDE_ASSIGN expression
Rule 89    expression -> MOD_ASSIGN expression
Rule 90    expression -> LPAREN expression RPAREN
Rule 91    expression -> INTEGER
Rule 92    expression -> empty
Rule 93    empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 
AND_ASSIGN           : 
ARRAYLIST            : 44 45 46 47 49
BLOCK_COMMENT        : 
BOOLEAN              : 9 18
BYTE                 : 15 24
CHAR                 : 14 23
COMA                 : 
CONCA                : 
CONCAT               : 
DEFAULT              : 30
DIVIDE               : 80
DIVIDE_ASSIGN        : 88
DOSCOMA              : 
DOUBLE               : 13 22
DOUBLELINKEDLIST     : 56 57 58 59 61
EQUAL                : 
EQUALS               : 42 48 54 60 66 72 75
ESPACIO              : 
FINAL                : 32 34
FLOAT                : 11 20
GREATTHAN            : 38 39 40 41 43 44 45 46 47 49 50 51 52 53 55 56 57 58 59 61 62 63 64 65 67 68 69 70 71 73 74
GREATTHANEQUAL       : 
INT                  : 8 17
INTEGER              : 91
LCORCHETE            : 
LESSTHAN             : 38 39 40 41 43 44 45 46 47 49 50 51 52 53 55 56 57 58 59 61 62 63 64 65 67 68 69 70 71 73 74
LESSTHANEQUAL        : 
LINKEDLIST           : 50 51 52 53 55 74
LIST                 : 38 39 40 41 43
LLLAVE               : 
LONG                 : 12 21
LPAREN               : 43 49 55 61 67 73 74 90
MINUS                : 78
MINUSMINUS           : 83
MINUS_ASSIGN         : 86
MOD                  : 81
MOD_ASSIGN           : 89
NEQUAL               : 
NEW                  : 43 49 55 61 67 73 74
NOT                  : 
NULL                 : 
OBJECT               : 16 25
OR                   : 
OR_ASSIGN            : 
PLUS                 : 77
PLUSPLUS             : 82
PLUS_ASSIGN          : 87
PRIVATE              : 28
PROTECTED            : 29
PUBLIC               : 27
PUNTO                : 
PUNTOCOMA            : 76
QUEUE                : 68 69 70 71 73
RCORCHETE            : 
RLLAVE               : 
RPAREN               : 43 49 55 61 67 73 74 90
SHORT                : 10 19
STACK                : 62 63 64 65 67
STATIC               : 33 34
STRING               : 66
TIMES                : 79
TIMESTIMES           : 84
TIMES_ASSIGN         : 85
VAR                  : 36 38 39 42 44 45 48 50 51 54 56 57 60 62 63 68 69 72 75
XOR                  : 
XOR_ASSIGN           : 
error                : 

Nonterminals, with rules where they appear

Type                 : 36 37 38 39 40 41 44 45 46 47 50 51 52 53 56 57 58 59 62 63 64 65 68 69 70 71
Typet                : 43 49 55 61 67 73 74
accessmodif          : 36 37 38 39 39 40 41 41 44 45 45 46 47 47 50 51 51 52 53 53 56 57 57 58 59 59 62 63 63 64 65 65 68 69 69 70 71 71
arrayassign          : 46 47
arraydeclaration     : 3
arrayexpression      : 48
assign               : 37
declaration          : 1
doublelinkedlistassign : 58 59
doublelinkedlistdeclaration : 5
doublelinkedlistexpression : 60
empty                : 26 31 35 92
endexpression        : 36 38 39 42 44 45 48 50 51 54 56 57 60 62 63 66 68 69 72 75
expression           : 75 77 77 78 78 79 79 80 80 81 81 84 84 85 86 87 88 89 90
finalstatvar         : 36 37 38 39 40 41 44 45 46 47 50 51 52 53 56 57 58 59 62 63 64 65 68 69 70 71
linkedlistassign     : 52 53
linkedlistdeclaration : 4
linkedlistexpression : 54
listassign           : 40 41
listdeclaration      : 2
listexpression       : 42
program              : 0
queueassign          : 70 71
queuedeclaration     : 7
queueexpression      : 72
stackassign          : 64 65
stackdeclaration     : 6
stackexpression      : 66

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration
    (2) program -> . listdeclaration
    (3) program -> . arraydeclaration
    (4) program -> . linkedlistdeclaration
    (5) program -> . doublelinkedlistdeclaration
    (6) program -> . stackdeclaration
    (7) program -> . queuedeclaration
    (36) declaration -> . accessmodif finalstatvar Type VAR endexpression
    (37) declaration -> . accessmodif finalstatvar Type assign
    (38) listdeclaration -> . accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression
    (39) listdeclaration -> . accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression
    (40) listdeclaration -> . accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN listassign
    (41) listdeclaration -> . accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN listassign
    (44) arraydeclaration -> . accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression
    (45) arraydeclaration -> . accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression
    (46) arraydeclaration -> . accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign
    (47) arraydeclaration -> . accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign
    (50) linkedlistdeclaration -> . accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (51) linkedlistdeclaration -> . accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (52) linkedlistdeclaration -> . accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign
    (53) linkedlistdeclaration -> . accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign
    (56) doublelinkedlistdeclaration -> . accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (57) doublelinkedlistdeclaration -> . accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (58) doublelinkedlistdeclaration -> . accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign
    (59) doublelinkedlistdeclaration -> . accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign
    (62) stackdeclaration -> . accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression
    (63) stackdeclaration -> . accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression
    (64) stackdeclaration -> . accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN stackassign
    (65) stackdeclaration -> . accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN stackassign
    (68) queuedeclaration -> . accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression
    (69) queuedeclaration -> . accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression
    (70) queuedeclaration -> . accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign
    (71) queuedeclaration -> . accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign
    (27) accessmodif -> . PUBLIC
    (28) accessmodif -> . PRIVATE
    (29) accessmodif -> . PROTECTED
    (30) accessmodif -> . DEFAULT
    (31) accessmodif -> . empty
    (93) empty -> .

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for PROTECTED resolved as shift
  ! shift/reduce conflict for DEFAULT resolved as shift
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    DEFAULT         shift and go to state 13
    FINAL           reduce using rule 93 (empty -> .)
    STATIC          reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)
    ARRAYLIST       reduce using rule 93 (empty -> .)
    LINKEDLIST      reduce using rule 93 (empty -> .)
    DOUBLELINKEDLIST reduce using rule 93 (empty -> .)
    STACK           reduce using rule 93 (empty -> .)
    QUEUE           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    BOOLEAN         reduce using rule 93 (empty -> .)
    SHORT           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    LONG            reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    BYTE            reduce using rule 93 (empty -> .)
    OBJECT          reduce using rule 93 (empty -> .)

  ! PUBLIC          [ reduce using rule 93 (empty -> .) ]
  ! PRIVATE         [ reduce using rule 93 (empty -> .) ]
  ! PROTECTED       [ reduce using rule 93 (empty -> .) ]
  ! DEFAULT         [ reduce using rule 93 (empty -> .) ]

    program                        shift and go to state 1
    declaration                    shift and go to state 2
    listdeclaration                shift and go to state 3
    arraydeclaration               shift and go to state 4
    linkedlistdeclaration          shift and go to state 5
    doublelinkedlistdeclaration    shift and go to state 6
    stackdeclaration               shift and go to state 7
    queuedeclaration               shift and go to state 8
    accessmodif                    shift and go to state 9
    empty                          shift and go to state 14

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration .

    $end            reduce using rule 1 (program -> declaration .)


state 3

    (2) program -> listdeclaration .

    $end            reduce using rule 2 (program -> listdeclaration .)


state 4

    (3) program -> arraydeclaration .

    $end            reduce using rule 3 (program -> arraydeclaration .)


state 5

    (4) program -> linkedlistdeclaration .

    $end            reduce using rule 4 (program -> linkedlistdeclaration .)


state 6

    (5) program -> doublelinkedlistdeclaration .

    $end            reduce using rule 5 (program -> doublelinkedlistdeclaration .)


state 7

    (6) program -> stackdeclaration .

    $end            reduce using rule 6 (program -> stackdeclaration .)


state 8

    (7) program -> queuedeclaration .

    $end            reduce using rule 7 (program -> queuedeclaration .)


state 9

    (36) declaration -> accessmodif . finalstatvar Type VAR endexpression
    (37) declaration -> accessmodif . finalstatvar Type assign
    (38) listdeclaration -> accessmodif . finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression
    (39) listdeclaration -> accessmodif . accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression
    (40) listdeclaration -> accessmodif . finalstatvar LIST LESSTHAN Type GREATTHAN listassign
    (41) listdeclaration -> accessmodif . accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN listassign
    (44) arraydeclaration -> accessmodif . finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression
    (45) arraydeclaration -> accessmodif . accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression
    (46) arraydeclaration -> accessmodif . finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign
    (47) arraydeclaration -> accessmodif . accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign
    (50) linkedlistdeclaration -> accessmodif . finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (51) linkedlistdeclaration -> accessmodif . accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (52) linkedlistdeclaration -> accessmodif . finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign
    (53) linkedlistdeclaration -> accessmodif . accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign
    (56) doublelinkedlistdeclaration -> accessmodif . finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (57) doublelinkedlistdeclaration -> accessmodif . accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (58) doublelinkedlistdeclaration -> accessmodif . finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign
    (59) doublelinkedlistdeclaration -> accessmodif . accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign
    (62) stackdeclaration -> accessmodif . finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression
    (63) stackdeclaration -> accessmodif . accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression
    (64) stackdeclaration -> accessmodif . finalstatvar STACK LESSTHAN Type GREATTHAN stackassign
    (65) stackdeclaration -> accessmodif . accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN stackassign
    (68) queuedeclaration -> accessmodif . finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression
    (69) queuedeclaration -> accessmodif . accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression
    (70) queuedeclaration -> accessmodif . finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign
    (71) queuedeclaration -> accessmodif . accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign
    (32) finalstatvar -> . FINAL
    (33) finalstatvar -> . STATIC
    (34) finalstatvar -> . FINAL STATIC
    (35) finalstatvar -> . empty
    (27) accessmodif -> . PUBLIC
    (28) accessmodif -> . PRIVATE
    (29) accessmodif -> . PROTECTED
    (30) accessmodif -> . DEFAULT
    (31) accessmodif -> . empty
    (93) empty -> .

  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
    FINAL           shift and go to state 17
    STATIC          shift and go to state 18
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    DEFAULT         shift and go to state 13
    LIST            reduce using rule 93 (empty -> .)
    ARRAYLIST       reduce using rule 93 (empty -> .)
    LINKEDLIST      reduce using rule 93 (empty -> .)
    DOUBLELINKEDLIST reduce using rule 93 (empty -> .)
    STACK           reduce using rule 93 (empty -> .)
    QUEUE           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    BOOLEAN         reduce using rule 93 (empty -> .)
    SHORT           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    LONG            reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    BYTE            reduce using rule 93 (empty -> .)
    OBJECT          reduce using rule 93 (empty -> .)

  ! FINAL           [ reduce using rule 93 (empty -> .) ]
  ! STATIC          [ reduce using rule 93 (empty -> .) ]

    accessmodif                    shift and go to state 15
    finalstatvar                   shift and go to state 16
    empty                          shift and go to state 19

state 10

    (27) accessmodif -> PUBLIC .

    FINAL           reduce using rule 27 (accessmodif -> PUBLIC .)
    STATIC          reduce using rule 27 (accessmodif -> PUBLIC .)
    PUBLIC          reduce using rule 27 (accessmodif -> PUBLIC .)
    PRIVATE         reduce using rule 27 (accessmodif -> PUBLIC .)
    PROTECTED       reduce using rule 27 (accessmodif -> PUBLIC .)
    DEFAULT         reduce using rule 27 (accessmodif -> PUBLIC .)
    LIST            reduce using rule 27 (accessmodif -> PUBLIC .)
    ARRAYLIST       reduce using rule 27 (accessmodif -> PUBLIC .)
    LINKEDLIST      reduce using rule 27 (accessmodif -> PUBLIC .)
    DOUBLELINKEDLIST reduce using rule 27 (accessmodif -> PUBLIC .)
    STACK           reduce using rule 27 (accessmodif -> PUBLIC .)
    QUEUE           reduce using rule 27 (accessmodif -> PUBLIC .)
    INT             reduce using rule 27 (accessmodif -> PUBLIC .)
    BOOLEAN         reduce using rule 27 (accessmodif -> PUBLIC .)
    SHORT           reduce using rule 27 (accessmodif -> PUBLIC .)
    FLOAT           reduce using rule 27 (accessmodif -> PUBLIC .)
    LONG            reduce using rule 27 (accessmodif -> PUBLIC .)
    DOUBLE          reduce using rule 27 (accessmodif -> PUBLIC .)
    CHAR            reduce using rule 27 (accessmodif -> PUBLIC .)
    BYTE            reduce using rule 27 (accessmodif -> PUBLIC .)
    OBJECT          reduce using rule 27 (accessmodif -> PUBLIC .)


state 11

    (28) accessmodif -> PRIVATE .

    FINAL           reduce using rule 28 (accessmodif -> PRIVATE .)
    STATIC          reduce using rule 28 (accessmodif -> PRIVATE .)
    PUBLIC          reduce using rule 28 (accessmodif -> PRIVATE .)
    PRIVATE         reduce using rule 28 (accessmodif -> PRIVATE .)
    PROTECTED       reduce using rule 28 (accessmodif -> PRIVATE .)
    DEFAULT         reduce using rule 28 (accessmodif -> PRIVATE .)
    LIST            reduce using rule 28 (accessmodif -> PRIVATE .)
    ARRAYLIST       reduce using rule 28 (accessmodif -> PRIVATE .)
    LINKEDLIST      reduce using rule 28 (accessmodif -> PRIVATE .)
    DOUBLELINKEDLIST reduce using rule 28 (accessmodif -> PRIVATE .)
    STACK           reduce using rule 28 (accessmodif -> PRIVATE .)
    QUEUE           reduce using rule 28 (accessmodif -> PRIVATE .)
    INT             reduce using rule 28 (accessmodif -> PRIVATE .)
    BOOLEAN         reduce using rule 28 (accessmodif -> PRIVATE .)
    SHORT           reduce using rule 28 (accessmodif -> PRIVATE .)
    FLOAT           reduce using rule 28 (accessmodif -> PRIVATE .)
    LONG            reduce using rule 28 (accessmodif -> PRIVATE .)
    DOUBLE          reduce using rule 28 (accessmodif -> PRIVATE .)
    CHAR            reduce using rule 28 (accessmodif -> PRIVATE .)
    BYTE            reduce using rule 28 (accessmodif -> PRIVATE .)
    OBJECT          reduce using rule 28 (accessmodif -> PRIVATE .)


state 12

    (29) accessmodif -> PROTECTED .

    FINAL           reduce using rule 29 (accessmodif -> PROTECTED .)
    STATIC          reduce using rule 29 (accessmodif -> PROTECTED .)
    PUBLIC          reduce using rule 29 (accessmodif -> PROTECTED .)
    PRIVATE         reduce using rule 29 (accessmodif -> PROTECTED .)
    PROTECTED       reduce using rule 29 (accessmodif -> PROTECTED .)
    DEFAULT         reduce using rule 29 (accessmodif -> PROTECTED .)
    LIST            reduce using rule 29 (accessmodif -> PROTECTED .)
    ARRAYLIST       reduce using rule 29 (accessmodif -> PROTECTED .)
    LINKEDLIST      reduce using rule 29 (accessmodif -> PROTECTED .)
    DOUBLELINKEDLIST reduce using rule 29 (accessmodif -> PROTECTED .)
    STACK           reduce using rule 29 (accessmodif -> PROTECTED .)
    QUEUE           reduce using rule 29 (accessmodif -> PROTECTED .)
    INT             reduce using rule 29 (accessmodif -> PROTECTED .)
    BOOLEAN         reduce using rule 29 (accessmodif -> PROTECTED .)
    SHORT           reduce using rule 29 (accessmodif -> PROTECTED .)
    FLOAT           reduce using rule 29 (accessmodif -> PROTECTED .)
    LONG            reduce using rule 29 (accessmodif -> PROTECTED .)
    DOUBLE          reduce using rule 29 (accessmodif -> PROTECTED .)
    CHAR            reduce using rule 29 (accessmodif -> PROTECTED .)
    BYTE            reduce using rule 29 (accessmodif -> PROTECTED .)
    OBJECT          reduce using rule 29 (accessmodif -> PROTECTED .)


state 13

    (30) accessmodif -> DEFAULT .

    FINAL           reduce using rule 30 (accessmodif -> DEFAULT .)
    STATIC          reduce using rule 30 (accessmodif -> DEFAULT .)
    PUBLIC          reduce using rule 30 (accessmodif -> DEFAULT .)
    PRIVATE         reduce using rule 30 (accessmodif -> DEFAULT .)
    PROTECTED       reduce using rule 30 (accessmodif -> DEFAULT .)
    DEFAULT         reduce using rule 30 (accessmodif -> DEFAULT .)
    LIST            reduce using rule 30 (accessmodif -> DEFAULT .)
    ARRAYLIST       reduce using rule 30 (accessmodif -> DEFAULT .)
    LINKEDLIST      reduce using rule 30 (accessmodif -> DEFAULT .)
    DOUBLELINKEDLIST reduce using rule 30 (accessmodif -> DEFAULT .)
    STACK           reduce using rule 30 (accessmodif -> DEFAULT .)
    QUEUE           reduce using rule 30 (accessmodif -> DEFAULT .)
    INT             reduce using rule 30 (accessmodif -> DEFAULT .)
    BOOLEAN         reduce using rule 30 (accessmodif -> DEFAULT .)
    SHORT           reduce using rule 30 (accessmodif -> DEFAULT .)
    FLOAT           reduce using rule 30 (accessmodif -> DEFAULT .)
    LONG            reduce using rule 30 (accessmodif -> DEFAULT .)
    DOUBLE          reduce using rule 30 (accessmodif -> DEFAULT .)
    CHAR            reduce using rule 30 (accessmodif -> DEFAULT .)
    BYTE            reduce using rule 30 (accessmodif -> DEFAULT .)
    OBJECT          reduce using rule 30 (accessmodif -> DEFAULT .)


state 14

    (31) accessmodif -> empty .

    FINAL           reduce using rule 31 (accessmodif -> empty .)
    STATIC          reduce using rule 31 (accessmodif -> empty .)
    PUBLIC          reduce using rule 31 (accessmodif -> empty .)
    PRIVATE         reduce using rule 31 (accessmodif -> empty .)
    PROTECTED       reduce using rule 31 (accessmodif -> empty .)
    DEFAULT         reduce using rule 31 (accessmodif -> empty .)
    LIST            reduce using rule 31 (accessmodif -> empty .)
    ARRAYLIST       reduce using rule 31 (accessmodif -> empty .)
    LINKEDLIST      reduce using rule 31 (accessmodif -> empty .)
    DOUBLELINKEDLIST reduce using rule 31 (accessmodif -> empty .)
    STACK           reduce using rule 31 (accessmodif -> empty .)
    QUEUE           reduce using rule 31 (accessmodif -> empty .)
    INT             reduce using rule 31 (accessmodif -> empty .)
    BOOLEAN         reduce using rule 31 (accessmodif -> empty .)
    SHORT           reduce using rule 31 (accessmodif -> empty .)
    FLOAT           reduce using rule 31 (accessmodif -> empty .)
    LONG            reduce using rule 31 (accessmodif -> empty .)
    DOUBLE          reduce using rule 31 (accessmodif -> empty .)
    CHAR            reduce using rule 31 (accessmodif -> empty .)
    BYTE            reduce using rule 31 (accessmodif -> empty .)
    OBJECT          reduce using rule 31 (accessmodif -> empty .)


state 15

    (39) listdeclaration -> accessmodif accessmodif . finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression
    (41) listdeclaration -> accessmodif accessmodif . finalstatvar LIST LESSTHAN Type GREATTHAN listassign
    (45) arraydeclaration -> accessmodif accessmodif . finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression
    (47) arraydeclaration -> accessmodif accessmodif . finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign
    (51) linkedlistdeclaration -> accessmodif accessmodif . finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (53) linkedlistdeclaration -> accessmodif accessmodif . finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign
    (57) doublelinkedlistdeclaration -> accessmodif accessmodif . finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (59) doublelinkedlistdeclaration -> accessmodif accessmodif . finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign
    (63) stackdeclaration -> accessmodif accessmodif . finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression
    (65) stackdeclaration -> accessmodif accessmodif . finalstatvar STACK LESSTHAN Type GREATTHAN stackassign
    (69) queuedeclaration -> accessmodif accessmodif . finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression
    (71) queuedeclaration -> accessmodif accessmodif . finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign
    (32) finalstatvar -> . FINAL
    (33) finalstatvar -> . STATIC
    (34) finalstatvar -> . FINAL STATIC
    (35) finalstatvar -> . empty
    (93) empty -> .

    FINAL           shift and go to state 17
    STATIC          shift and go to state 18
    LIST            reduce using rule 93 (empty -> .)
    ARRAYLIST       reduce using rule 93 (empty -> .)
    LINKEDLIST      reduce using rule 93 (empty -> .)
    DOUBLELINKEDLIST reduce using rule 93 (empty -> .)
    STACK           reduce using rule 93 (empty -> .)
    QUEUE           reduce using rule 93 (empty -> .)

    finalstatvar                   shift and go to state 20
    empty                          shift and go to state 21

state 16

    (36) declaration -> accessmodif finalstatvar . Type VAR endexpression
    (37) declaration -> accessmodif finalstatvar . Type assign
    (38) listdeclaration -> accessmodif finalstatvar . LIST LESSTHAN Type GREATTHAN VAR endexpression
    (40) listdeclaration -> accessmodif finalstatvar . LIST LESSTHAN Type GREATTHAN listassign
    (44) arraydeclaration -> accessmodif finalstatvar . ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression
    (46) arraydeclaration -> accessmodif finalstatvar . ARRAYLIST LESSTHAN Type GREATTHAN arrayassign
    (50) linkedlistdeclaration -> accessmodif finalstatvar . LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (52) linkedlistdeclaration -> accessmodif finalstatvar . LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign
    (56) doublelinkedlistdeclaration -> accessmodif finalstatvar . DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (58) doublelinkedlistdeclaration -> accessmodif finalstatvar . DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign
    (62) stackdeclaration -> accessmodif finalstatvar . STACK LESSTHAN Type GREATTHAN VAR endexpression
    (64) stackdeclaration -> accessmodif finalstatvar . STACK LESSTHAN Type GREATTHAN stackassign
    (68) queuedeclaration -> accessmodif finalstatvar . QUEUE LESSTHAN Type GREATTHAN VAR endexpression
    (70) queuedeclaration -> accessmodif finalstatvar . QUEUE LESSTHAN Type GREATTHAN queueassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    LIST            shift and go to state 23
    ARRAYLIST       shift and go to state 24
    LINKEDLIST      shift and go to state 25
    DOUBLELINKEDLIST shift and go to state 26
    STACK           shift and go to state 27
    QUEUE           shift and go to state 28
    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 22

state 17

    (32) finalstatvar -> FINAL .
    (34) finalstatvar -> FINAL . STATIC

    LIST            reduce using rule 32 (finalstatvar -> FINAL .)
    ARRAYLIST       reduce using rule 32 (finalstatvar -> FINAL .)
    LINKEDLIST      reduce using rule 32 (finalstatvar -> FINAL .)
    DOUBLELINKEDLIST reduce using rule 32 (finalstatvar -> FINAL .)
    STACK           reduce using rule 32 (finalstatvar -> FINAL .)
    QUEUE           reduce using rule 32 (finalstatvar -> FINAL .)
    INT             reduce using rule 32 (finalstatvar -> FINAL .)
    BOOLEAN         reduce using rule 32 (finalstatvar -> FINAL .)
    SHORT           reduce using rule 32 (finalstatvar -> FINAL .)
    FLOAT           reduce using rule 32 (finalstatvar -> FINAL .)
    LONG            reduce using rule 32 (finalstatvar -> FINAL .)
    DOUBLE          reduce using rule 32 (finalstatvar -> FINAL .)
    CHAR            reduce using rule 32 (finalstatvar -> FINAL .)
    BYTE            reduce using rule 32 (finalstatvar -> FINAL .)
    OBJECT          reduce using rule 32 (finalstatvar -> FINAL .)
    STATIC          shift and go to state 38


state 18

    (33) finalstatvar -> STATIC .

    LIST            reduce using rule 33 (finalstatvar -> STATIC .)
    ARRAYLIST       reduce using rule 33 (finalstatvar -> STATIC .)
    LINKEDLIST      reduce using rule 33 (finalstatvar -> STATIC .)
    DOUBLELINKEDLIST reduce using rule 33 (finalstatvar -> STATIC .)
    STACK           reduce using rule 33 (finalstatvar -> STATIC .)
    QUEUE           reduce using rule 33 (finalstatvar -> STATIC .)
    INT             reduce using rule 33 (finalstatvar -> STATIC .)
    BOOLEAN         reduce using rule 33 (finalstatvar -> STATIC .)
    SHORT           reduce using rule 33 (finalstatvar -> STATIC .)
    FLOAT           reduce using rule 33 (finalstatvar -> STATIC .)
    LONG            reduce using rule 33 (finalstatvar -> STATIC .)
    DOUBLE          reduce using rule 33 (finalstatvar -> STATIC .)
    CHAR            reduce using rule 33 (finalstatvar -> STATIC .)
    BYTE            reduce using rule 33 (finalstatvar -> STATIC .)
    OBJECT          reduce using rule 33 (finalstatvar -> STATIC .)


state 19

    (35) finalstatvar -> empty .
    (31) accessmodif -> empty .

  ! reduce/reduce conflict for LIST resolved using rule 31 (accessmodif -> empty .)
  ! reduce/reduce conflict for ARRAYLIST resolved using rule 31 (accessmodif -> empty .)
  ! reduce/reduce conflict for LINKEDLIST resolved using rule 31 (accessmodif -> empty .)
  ! reduce/reduce conflict for DOUBLELINKEDLIST resolved using rule 31 (accessmodif -> empty .)
  ! reduce/reduce conflict for STACK resolved using rule 31 (accessmodif -> empty .)
  ! reduce/reduce conflict for QUEUE resolved using rule 31 (accessmodif -> empty .)
    INT             reduce using rule 35 (finalstatvar -> empty .)
    BOOLEAN         reduce using rule 35 (finalstatvar -> empty .)
    SHORT           reduce using rule 35 (finalstatvar -> empty .)
    FLOAT           reduce using rule 35 (finalstatvar -> empty .)
    LONG            reduce using rule 35 (finalstatvar -> empty .)
    DOUBLE          reduce using rule 35 (finalstatvar -> empty .)
    CHAR            reduce using rule 35 (finalstatvar -> empty .)
    BYTE            reduce using rule 35 (finalstatvar -> empty .)
    OBJECT          reduce using rule 35 (finalstatvar -> empty .)
    FINAL           reduce using rule 31 (accessmodif -> empty .)
    STATIC          reduce using rule 31 (accessmodif -> empty .)
    LIST            reduce using rule 31 (accessmodif -> empty .)
    ARRAYLIST       reduce using rule 31 (accessmodif -> empty .)
    LINKEDLIST      reduce using rule 31 (accessmodif -> empty .)
    DOUBLELINKEDLIST reduce using rule 31 (accessmodif -> empty .)
    STACK           reduce using rule 31 (accessmodif -> empty .)
    QUEUE           reduce using rule 31 (accessmodif -> empty .)

  ! LIST            [ reduce using rule 35 (finalstatvar -> empty .) ]
  ! ARRAYLIST       [ reduce using rule 35 (finalstatvar -> empty .) ]
  ! LINKEDLIST      [ reduce using rule 35 (finalstatvar -> empty .) ]
  ! DOUBLELINKEDLIST [ reduce using rule 35 (finalstatvar -> empty .) ]
  ! STACK           [ reduce using rule 35 (finalstatvar -> empty .) ]
  ! QUEUE           [ reduce using rule 35 (finalstatvar -> empty .) ]


state 20

    (39) listdeclaration -> accessmodif accessmodif finalstatvar . LIST LESSTHAN Type GREATTHAN VAR endexpression
    (41) listdeclaration -> accessmodif accessmodif finalstatvar . LIST LESSTHAN Type GREATTHAN listassign
    (45) arraydeclaration -> accessmodif accessmodif finalstatvar . ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression
    (47) arraydeclaration -> accessmodif accessmodif finalstatvar . ARRAYLIST LESSTHAN Type GREATTHAN arrayassign
    (51) linkedlistdeclaration -> accessmodif accessmodif finalstatvar . LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (53) linkedlistdeclaration -> accessmodif accessmodif finalstatvar . LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign
    (57) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar . DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression
    (59) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar . DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign
    (63) stackdeclaration -> accessmodif accessmodif finalstatvar . STACK LESSTHAN Type GREATTHAN VAR endexpression
    (65) stackdeclaration -> accessmodif accessmodif finalstatvar . STACK LESSTHAN Type GREATTHAN stackassign
    (69) queuedeclaration -> accessmodif accessmodif finalstatvar . QUEUE LESSTHAN Type GREATTHAN VAR endexpression
    (71) queuedeclaration -> accessmodif accessmodif finalstatvar . QUEUE LESSTHAN Type GREATTHAN queueassign

    LIST            shift and go to state 39
    ARRAYLIST       shift and go to state 40
    LINKEDLIST      shift and go to state 41
    DOUBLELINKEDLIST shift and go to state 42
    STACK           shift and go to state 43
    QUEUE           shift and go to state 44


state 21

    (35) finalstatvar -> empty .

    LIST            reduce using rule 35 (finalstatvar -> empty .)
    ARRAYLIST       reduce using rule 35 (finalstatvar -> empty .)
    LINKEDLIST      reduce using rule 35 (finalstatvar -> empty .)
    DOUBLELINKEDLIST reduce using rule 35 (finalstatvar -> empty .)
    STACK           reduce using rule 35 (finalstatvar -> empty .)
    QUEUE           reduce using rule 35 (finalstatvar -> empty .)


state 22

    (36) declaration -> accessmodif finalstatvar Type . VAR endexpression
    (37) declaration -> accessmodif finalstatvar Type . assign
    (75) assign -> . VAR EQUALS expression endexpression

    VAR             shift and go to state 45

    assign                         shift and go to state 46

state 23

    (38) listdeclaration -> accessmodif finalstatvar LIST . LESSTHAN Type GREATTHAN VAR endexpression
    (40) listdeclaration -> accessmodif finalstatvar LIST . LESSTHAN Type GREATTHAN listassign

    LESSTHAN        shift and go to state 47


state 24

    (44) arraydeclaration -> accessmodif finalstatvar ARRAYLIST . LESSTHAN Type GREATTHAN VAR endexpression
    (46) arraydeclaration -> accessmodif finalstatvar ARRAYLIST . LESSTHAN Type GREATTHAN arrayassign

    LESSTHAN        shift and go to state 48


state 25

    (50) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST . LESSTHAN Type GREATTHAN VAR endexpression
    (52) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST . LESSTHAN Type GREATTHAN linkedlistassign

    LESSTHAN        shift and go to state 49


state 26

    (56) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST . LESSTHAN Type GREATTHAN VAR endexpression
    (58) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST . LESSTHAN Type GREATTHAN doublelinkedlistassign

    LESSTHAN        shift and go to state 50


state 27

    (62) stackdeclaration -> accessmodif finalstatvar STACK . LESSTHAN Type GREATTHAN VAR endexpression
    (64) stackdeclaration -> accessmodif finalstatvar STACK . LESSTHAN Type GREATTHAN stackassign

    LESSTHAN        shift and go to state 51


state 28

    (68) queuedeclaration -> accessmodif finalstatvar QUEUE . LESSTHAN Type GREATTHAN VAR endexpression
    (70) queuedeclaration -> accessmodif finalstatvar QUEUE . LESSTHAN Type GREATTHAN queueassign

    LESSTHAN        shift and go to state 52


state 29

    (8) Type -> INT .

    VAR             reduce using rule 8 (Type -> INT .)
    GREATTHAN       reduce using rule 8 (Type -> INT .)


state 30

    (9) Type -> BOOLEAN .

    VAR             reduce using rule 9 (Type -> BOOLEAN .)
    GREATTHAN       reduce using rule 9 (Type -> BOOLEAN .)


state 31

    (10) Type -> SHORT .

    VAR             reduce using rule 10 (Type -> SHORT .)
    GREATTHAN       reduce using rule 10 (Type -> SHORT .)


state 32

    (11) Type -> FLOAT .

    VAR             reduce using rule 11 (Type -> FLOAT .)
    GREATTHAN       reduce using rule 11 (Type -> FLOAT .)


state 33

    (12) Type -> LONG .

    VAR             reduce using rule 12 (Type -> LONG .)
    GREATTHAN       reduce using rule 12 (Type -> LONG .)


state 34

    (13) Type -> DOUBLE .

    VAR             reduce using rule 13 (Type -> DOUBLE .)
    GREATTHAN       reduce using rule 13 (Type -> DOUBLE .)


state 35

    (14) Type -> CHAR .

    VAR             reduce using rule 14 (Type -> CHAR .)
    GREATTHAN       reduce using rule 14 (Type -> CHAR .)


state 36

    (15) Type -> BYTE .

    VAR             reduce using rule 15 (Type -> BYTE .)
    GREATTHAN       reduce using rule 15 (Type -> BYTE .)


state 37

    (16) Type -> OBJECT .

    VAR             reduce using rule 16 (Type -> OBJECT .)
    GREATTHAN       reduce using rule 16 (Type -> OBJECT .)


state 38

    (34) finalstatvar -> FINAL STATIC .

    LIST            reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    ARRAYLIST       reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    LINKEDLIST      reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    DOUBLELINKEDLIST reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    STACK           reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    QUEUE           reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    INT             reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    BOOLEAN         reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    SHORT           reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    FLOAT           reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    LONG            reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    DOUBLE          reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    CHAR            reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    BYTE            reduce using rule 34 (finalstatvar -> FINAL STATIC .)
    OBJECT          reduce using rule 34 (finalstatvar -> FINAL STATIC .)


state 39

    (39) listdeclaration -> accessmodif accessmodif finalstatvar LIST . LESSTHAN Type GREATTHAN VAR endexpression
    (41) listdeclaration -> accessmodif accessmodif finalstatvar LIST . LESSTHAN Type GREATTHAN listassign

    LESSTHAN        shift and go to state 53


state 40

    (45) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST . LESSTHAN Type GREATTHAN VAR endexpression
    (47) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST . LESSTHAN Type GREATTHAN arrayassign

    LESSTHAN        shift and go to state 54


state 41

    (51) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST . LESSTHAN Type GREATTHAN VAR endexpression
    (53) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST . LESSTHAN Type GREATTHAN linkedlistassign

    LESSTHAN        shift and go to state 55


state 42

    (57) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST . LESSTHAN Type GREATTHAN VAR endexpression
    (59) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST . LESSTHAN Type GREATTHAN doublelinkedlistassign

    LESSTHAN        shift and go to state 56


state 43

    (63) stackdeclaration -> accessmodif accessmodif finalstatvar STACK . LESSTHAN Type GREATTHAN VAR endexpression
    (65) stackdeclaration -> accessmodif accessmodif finalstatvar STACK . LESSTHAN Type GREATTHAN stackassign

    LESSTHAN        shift and go to state 57


state 44

    (69) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE . LESSTHAN Type GREATTHAN VAR endexpression
    (71) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE . LESSTHAN Type GREATTHAN queueassign

    LESSTHAN        shift and go to state 58


state 45

    (36) declaration -> accessmodif finalstatvar Type VAR . endexpression
    (75) assign -> VAR . EQUALS expression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 60
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 59

state 46

    (37) declaration -> accessmodif finalstatvar Type assign .

    $end            reduce using rule 37 (declaration -> accessmodif finalstatvar Type assign .)


state 47

    (38) listdeclaration -> accessmodif finalstatvar LIST LESSTHAN . Type GREATTHAN VAR endexpression
    (40) listdeclaration -> accessmodif finalstatvar LIST LESSTHAN . Type GREATTHAN listassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 62

state 48

    (44) arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN . Type GREATTHAN VAR endexpression
    (46) arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN . Type GREATTHAN arrayassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 63

state 49

    (50) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN . Type GREATTHAN VAR endexpression
    (52) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN . Type GREATTHAN linkedlistassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 64

state 50

    (56) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN . Type GREATTHAN VAR endexpression
    (58) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN . Type GREATTHAN doublelinkedlistassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 65

state 51

    (62) stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN . Type GREATTHAN VAR endexpression
    (64) stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN . Type GREATTHAN stackassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 66

state 52

    (68) queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN . Type GREATTHAN VAR endexpression
    (70) queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN . Type GREATTHAN queueassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 67

state 53

    (39) listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN . Type GREATTHAN VAR endexpression
    (41) listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN . Type GREATTHAN listassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 68

state 54

    (45) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN . Type GREATTHAN VAR endexpression
    (47) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN . Type GREATTHAN arrayassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 69

state 55

    (51) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN . Type GREATTHAN VAR endexpression
    (53) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN . Type GREATTHAN linkedlistassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 70

state 56

    (57) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN . Type GREATTHAN VAR endexpression
    (59) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN . Type GREATTHAN doublelinkedlistassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 71

state 57

    (63) stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN . Type GREATTHAN VAR endexpression
    (65) stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN . Type GREATTHAN stackassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 72

state 58

    (69) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN . Type GREATTHAN VAR endexpression
    (71) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN . Type GREATTHAN queueassign
    (8) Type -> . INT
    (9) Type -> . BOOLEAN
    (10) Type -> . SHORT
    (11) Type -> . FLOAT
    (12) Type -> . LONG
    (13) Type -> . DOUBLE
    (14) Type -> . CHAR
    (15) Type -> . BYTE
    (16) Type -> . OBJECT

    INT             shift and go to state 29
    BOOLEAN         shift and go to state 30
    SHORT           shift and go to state 31
    FLOAT           shift and go to state 32
    LONG            shift and go to state 33
    DOUBLE          shift and go to state 34
    CHAR            shift and go to state 35
    BYTE            shift and go to state 36
    OBJECT          shift and go to state 37

    Type                           shift and go to state 73

state 59

    (36) declaration -> accessmodif finalstatvar Type VAR endexpression .

    $end            reduce using rule 36 (declaration -> accessmodif finalstatvar Type VAR endexpression .)


state 60

    (75) assign -> VAR EQUALS . expression endexpression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)

    expression                     shift and go to state 74
    empty                          shift and go to state 84

state 61

    (76) endexpression -> PUNTOCOMA .

    $end            reduce using rule 76 (endexpression -> PUNTOCOMA .)


state 62

    (38) listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type . GREATTHAN VAR endexpression
    (40) listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type . GREATTHAN listassign

    GREATTHAN       shift and go to state 85


state 63

    (44) arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type . GREATTHAN VAR endexpression
    (46) arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type . GREATTHAN arrayassign

    GREATTHAN       shift and go to state 86


state 64

    (50) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type . GREATTHAN VAR endexpression
    (52) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type . GREATTHAN linkedlistassign

    GREATTHAN       shift and go to state 87


state 65

    (56) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type . GREATTHAN VAR endexpression
    (58) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type . GREATTHAN doublelinkedlistassign

    GREATTHAN       shift and go to state 88


state 66

    (62) stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type . GREATTHAN VAR endexpression
    (64) stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type . GREATTHAN stackassign

    GREATTHAN       shift and go to state 89


state 67

    (68) queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type . GREATTHAN VAR endexpression
    (70) queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type . GREATTHAN queueassign

    GREATTHAN       shift and go to state 90


state 68

    (39) listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type . GREATTHAN VAR endexpression
    (41) listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type . GREATTHAN listassign

    GREATTHAN       shift and go to state 91


state 69

    (45) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type . GREATTHAN VAR endexpression
    (47) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type . GREATTHAN arrayassign

    GREATTHAN       shift and go to state 92


state 70

    (51) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type . GREATTHAN VAR endexpression
    (53) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type . GREATTHAN linkedlistassign

    GREATTHAN       shift and go to state 93


state 71

    (57) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type . GREATTHAN VAR endexpression
    (59) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type . GREATTHAN doublelinkedlistassign

    GREATTHAN       shift and go to state 94


state 72

    (63) stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type . GREATTHAN VAR endexpression
    (65) stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type . GREATTHAN stackassign

    GREATTHAN       shift and go to state 95


state 73

    (69) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type . GREATTHAN VAR endexpression
    (71) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type . GREATTHAN queueassign

    GREATTHAN       shift and go to state 96


state 74

    (75) assign -> VAR EQUALS expression . endexpression
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression
    (76) endexpression -> . PUNTOCOMA

    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MOD             shift and go to state 102
    TIMESTIMES      shift and go to state 103
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 97

state 75

    (82) expression -> PLUSPLUS .

    PLUS            reduce using rule 82 (expression -> PLUSPLUS .)
    MINUS           reduce using rule 82 (expression -> PLUSPLUS .)
    TIMES           reduce using rule 82 (expression -> PLUSPLUS .)
    DIVIDE          reduce using rule 82 (expression -> PLUSPLUS .)
    MOD             reduce using rule 82 (expression -> PLUSPLUS .)
    TIMESTIMES      reduce using rule 82 (expression -> PLUSPLUS .)
    PUNTOCOMA       reduce using rule 82 (expression -> PLUSPLUS .)
    RPAREN          reduce using rule 82 (expression -> PLUSPLUS .)


state 76

    (83) expression -> MINUSMINUS .

    PLUS            reduce using rule 83 (expression -> MINUSMINUS .)
    MINUS           reduce using rule 83 (expression -> MINUSMINUS .)
    TIMES           reduce using rule 83 (expression -> MINUSMINUS .)
    DIVIDE          reduce using rule 83 (expression -> MINUSMINUS .)
    MOD             reduce using rule 83 (expression -> MINUSMINUS .)
    TIMESTIMES      reduce using rule 83 (expression -> MINUSMINUS .)
    PUNTOCOMA       reduce using rule 83 (expression -> MINUSMINUS .)
    RPAREN          reduce using rule 83 (expression -> MINUSMINUS .)


state 77

    (85) expression -> TIMES_ASSIGN . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 104
    empty                          shift and go to state 84

state 78

    (86) expression -> MINUS_ASSIGN . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 105
    empty                          shift and go to state 84

state 79

    (87) expression -> PLUS_ASSIGN . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 106
    empty                          shift and go to state 84

state 80

    (88) expression -> DIVIDE_ASSIGN . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 107
    empty                          shift and go to state 84

state 81

    (89) expression -> MOD_ASSIGN . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 108
    empty                          shift and go to state 84

state 82

    (90) expression -> LPAREN . expression RPAREN
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    RPAREN          reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)

    expression                     shift and go to state 109
    empty                          shift and go to state 84

state 83

    (91) expression -> INTEGER .

    PLUS            reduce using rule 91 (expression -> INTEGER .)
    MINUS           reduce using rule 91 (expression -> INTEGER .)
    TIMES           reduce using rule 91 (expression -> INTEGER .)
    DIVIDE          reduce using rule 91 (expression -> INTEGER .)
    MOD             reduce using rule 91 (expression -> INTEGER .)
    TIMESTIMES      reduce using rule 91 (expression -> INTEGER .)
    PUNTOCOMA       reduce using rule 91 (expression -> INTEGER .)
    RPAREN          reduce using rule 91 (expression -> INTEGER .)


state 84

    (92) expression -> empty .

    PLUS            reduce using rule 92 (expression -> empty .)
    MINUS           reduce using rule 92 (expression -> empty .)
    TIMES           reduce using rule 92 (expression -> empty .)
    DIVIDE          reduce using rule 92 (expression -> empty .)
    MOD             reduce using rule 92 (expression -> empty .)
    TIMESTIMES      reduce using rule 92 (expression -> empty .)
    PUNTOCOMA       reduce using rule 92 (expression -> empty .)
    RPAREN          reduce using rule 92 (expression -> empty .)


state 85

    (38) listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN . VAR endexpression
    (40) listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN . listassign
    (42) listassign -> . VAR EQUALS listexpression endexpression

    VAR             shift and go to state 110

    listassign                     shift and go to state 111

state 86

    (44) arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN . VAR endexpression
    (46) arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN . arrayassign
    (48) arrayassign -> . VAR EQUALS arrayexpression endexpression

    VAR             shift and go to state 112

    arrayassign                    shift and go to state 113

state 87

    (50) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN . VAR endexpression
    (52) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN . linkedlistassign
    (54) linkedlistassign -> . VAR EQUALS linkedlistexpression endexpression

    VAR             shift and go to state 114

    linkedlistassign               shift and go to state 115

state 88

    (56) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN . VAR endexpression
    (58) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN . doublelinkedlistassign
    (60) doublelinkedlistassign -> . VAR EQUALS doublelinkedlistexpression endexpression

    VAR             shift and go to state 116

    doublelinkedlistassign         shift and go to state 117

state 89

    (62) stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN . VAR endexpression
    (64) stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN . stackassign
    (66) stackassign -> . STRING EQUALS stackexpression endexpression

    VAR             shift and go to state 118
    STRING          shift and go to state 120

    stackassign                    shift and go to state 119

state 90

    (68) queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN . VAR endexpression
    (70) queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN . queueassign
    (72) queueassign -> . VAR EQUALS queueexpression endexpression

    VAR             shift and go to state 121

    queueassign                    shift and go to state 122

state 91

    (39) listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN . VAR endexpression
    (41) listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN . listassign
    (42) listassign -> . VAR EQUALS listexpression endexpression

    VAR             shift and go to state 123

    listassign                     shift and go to state 124

state 92

    (45) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN . VAR endexpression
    (47) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN . arrayassign
    (48) arrayassign -> . VAR EQUALS arrayexpression endexpression

    VAR             shift and go to state 125

    arrayassign                    shift and go to state 126

state 93

    (51) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN . VAR endexpression
    (53) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN . linkedlistassign
    (54) linkedlistassign -> . VAR EQUALS linkedlistexpression endexpression

    VAR             shift and go to state 127

    linkedlistassign               shift and go to state 128

state 94

    (57) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN . VAR endexpression
    (59) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN . doublelinkedlistassign
    (60) doublelinkedlistassign -> . VAR EQUALS doublelinkedlistexpression endexpression

    VAR             shift and go to state 129

    doublelinkedlistassign         shift and go to state 130

state 95

    (63) stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN . VAR endexpression
    (65) stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN . stackassign
    (66) stackassign -> . STRING EQUALS stackexpression endexpression

    VAR             shift and go to state 131
    STRING          shift and go to state 120

    stackassign                    shift and go to state 132

state 96

    (69) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN . VAR endexpression
    (71) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN . queueassign
    (72) queueassign -> . VAR EQUALS queueexpression endexpression

    VAR             shift and go to state 133

    queueassign                    shift and go to state 134

state 97

    (75) assign -> VAR EQUALS expression endexpression .

    $end            reduce using rule 75 (assign -> VAR EQUALS expression endexpression .)


state 98

    (77) expression -> expression PLUS . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 135
    empty                          shift and go to state 84

state 99

    (78) expression -> expression MINUS . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 136
    empty                          shift and go to state 84

state 100

    (79) expression -> expression TIMES . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 137
    empty                          shift and go to state 84

state 101

    (80) expression -> expression DIVIDE . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 138
    empty                          shift and go to state 84

state 102

    (81) expression -> expression MOD . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 139
    empty                          shift and go to state 84

state 103

    (84) expression -> expression TIMESTIMES . expression
    (77) expression -> . expression PLUS expression
    (78) expression -> . expression MINUS expression
    (79) expression -> . expression TIMES expression
    (80) expression -> . expression DIVIDE expression
    (81) expression -> . expression MOD expression
    (82) expression -> . PLUSPLUS
    (83) expression -> . MINUSMINUS
    (84) expression -> . expression TIMESTIMES expression
    (85) expression -> . TIMES_ASSIGN expression
    (86) expression -> . MINUS_ASSIGN expression
    (87) expression -> . PLUS_ASSIGN expression
    (88) expression -> . DIVIDE_ASSIGN expression
    (89) expression -> . MOD_ASSIGN expression
    (90) expression -> . LPAREN expression RPAREN
    (91) expression -> . INTEGER
    (92) expression -> . empty
    (93) empty -> .

    PLUSPLUS        shift and go to state 75
    MINUSMINUS      shift and go to state 76
    TIMES_ASSIGN    shift and go to state 77
    MINUS_ASSIGN    shift and go to state 78
    PLUS_ASSIGN     shift and go to state 79
    DIVIDE_ASSIGN   shift and go to state 80
    MOD_ASSIGN      shift and go to state 81
    LPAREN          shift and go to state 82
    INTEGER         shift and go to state 83
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    TIMES           reduce using rule 93 (empty -> .)
    DIVIDE          reduce using rule 93 (empty -> .)
    MOD             reduce using rule 93 (empty -> .)
    TIMESTIMES      reduce using rule 93 (empty -> .)
    PUNTOCOMA       reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    expression                     shift and go to state 140
    empty                          shift and go to state 84

state 104

    (85) expression -> TIMES_ASSIGN expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for TIMESTIMES resolved as shift
    PUNTOCOMA       reduce using rule 85 (expression -> TIMES_ASSIGN expression .)
    RPAREN          reduce using rule 85 (expression -> TIMES_ASSIGN expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MOD             shift and go to state 102
    TIMESTIMES      shift and go to state 103

  ! PLUS            [ reduce using rule 85 (expression -> TIMES_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 85 (expression -> TIMES_ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 85 (expression -> TIMES_ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 85 (expression -> TIMES_ASSIGN expression .) ]
  ! MOD             [ reduce using rule 85 (expression -> TIMES_ASSIGN expression .) ]
  ! TIMESTIMES      [ reduce using rule 85 (expression -> TIMES_ASSIGN expression .) ]


state 105

    (86) expression -> MINUS_ASSIGN expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for TIMESTIMES resolved as shift
    PUNTOCOMA       reduce using rule 86 (expression -> MINUS_ASSIGN expression .)
    RPAREN          reduce using rule 86 (expression -> MINUS_ASSIGN expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MOD             shift and go to state 102
    TIMESTIMES      shift and go to state 103

  ! PLUS            [ reduce using rule 86 (expression -> MINUS_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 86 (expression -> MINUS_ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 86 (expression -> MINUS_ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 86 (expression -> MINUS_ASSIGN expression .) ]
  ! MOD             [ reduce using rule 86 (expression -> MINUS_ASSIGN expression .) ]
  ! TIMESTIMES      [ reduce using rule 86 (expression -> MINUS_ASSIGN expression .) ]


state 106

    (87) expression -> PLUS_ASSIGN expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for TIMESTIMES resolved as shift
    PUNTOCOMA       reduce using rule 87 (expression -> PLUS_ASSIGN expression .)
    RPAREN          reduce using rule 87 (expression -> PLUS_ASSIGN expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MOD             shift and go to state 102
    TIMESTIMES      shift and go to state 103

  ! PLUS            [ reduce using rule 87 (expression -> PLUS_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 87 (expression -> PLUS_ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 87 (expression -> PLUS_ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 87 (expression -> PLUS_ASSIGN expression .) ]
  ! MOD             [ reduce using rule 87 (expression -> PLUS_ASSIGN expression .) ]
  ! TIMESTIMES      [ reduce using rule 87 (expression -> PLUS_ASSIGN expression .) ]


state 107

    (88) expression -> DIVIDE_ASSIGN expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for TIMESTIMES resolved as shift
    PUNTOCOMA       reduce using rule 88 (expression -> DIVIDE_ASSIGN expression .)
    RPAREN          reduce using rule 88 (expression -> DIVIDE_ASSIGN expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MOD             shift and go to state 102
    TIMESTIMES      shift and go to state 103

  ! PLUS            [ reduce using rule 88 (expression -> DIVIDE_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 88 (expression -> DIVIDE_ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 88 (expression -> DIVIDE_ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 88 (expression -> DIVIDE_ASSIGN expression .) ]
  ! MOD             [ reduce using rule 88 (expression -> DIVIDE_ASSIGN expression .) ]
  ! TIMESTIMES      [ reduce using rule 88 (expression -> DIVIDE_ASSIGN expression .) ]


state 108

    (89) expression -> MOD_ASSIGN expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for TIMESTIMES resolved as shift
    PUNTOCOMA       reduce using rule 89 (expression -> MOD_ASSIGN expression .)
    RPAREN          reduce using rule 89 (expression -> MOD_ASSIGN expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MOD             shift and go to state 102
    TIMESTIMES      shift and go to state 103

  ! PLUS            [ reduce using rule 89 (expression -> MOD_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 89 (expression -> MOD_ASSIGN expression .) ]
  ! TIMES           [ reduce using rule 89 (expression -> MOD_ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 89 (expression -> MOD_ASSIGN expression .) ]
  ! MOD             [ reduce using rule 89 (expression -> MOD_ASSIGN expression .) ]
  ! TIMESTIMES      [ reduce using rule 89 (expression -> MOD_ASSIGN expression .) ]


state 109

    (90) expression -> LPAREN expression . RPAREN
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

    RPAREN          shift and go to state 141
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MOD             shift and go to state 102
    TIMESTIMES      shift and go to state 103


state 110

    (38) listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR . endexpression
    (42) listassign -> VAR . EQUALS listexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 143
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 142

state 111

    (40) listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN listassign .

    $end            reduce using rule 40 (listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN listassign .)


state 112

    (44) arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR . endexpression
    (48) arrayassign -> VAR . EQUALS arrayexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 145
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 144

state 113

    (46) arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign .

    $end            reduce using rule 46 (arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign .)


state 114

    (50) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR . endexpression
    (54) linkedlistassign -> VAR . EQUALS linkedlistexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 147
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 146

state 115

    (52) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign .

    $end            reduce using rule 52 (linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign .)


state 116

    (56) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR . endexpression
    (60) doublelinkedlistassign -> VAR . EQUALS doublelinkedlistexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 149
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 148

state 117

    (58) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign .

    $end            reduce using rule 58 (doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign .)


state 118

    (62) stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR . endexpression
    (76) endexpression -> . PUNTOCOMA

    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 150

state 119

    (64) stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN stackassign .

    $end            reduce using rule 64 (stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN stackassign .)


state 120

    (66) stackassign -> STRING . EQUALS stackexpression endexpression

    EQUALS          shift and go to state 151


state 121

    (68) queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR . endexpression
    (72) queueassign -> VAR . EQUALS queueexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 153
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 152

state 122

    (70) queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign .

    $end            reduce using rule 70 (queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign .)


state 123

    (39) listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR . endexpression
    (42) listassign -> VAR . EQUALS listexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 143
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 154

state 124

    (41) listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN listassign .

    $end            reduce using rule 41 (listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN listassign .)


state 125

    (45) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR . endexpression
    (48) arrayassign -> VAR . EQUALS arrayexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 145
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 155

state 126

    (47) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign .

    $end            reduce using rule 47 (arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN arrayassign .)


state 127

    (51) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR . endexpression
    (54) linkedlistassign -> VAR . EQUALS linkedlistexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 147
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 156

state 128

    (53) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign .

    $end            reduce using rule 53 (linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN linkedlistassign .)


state 129

    (57) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR . endexpression
    (60) doublelinkedlistassign -> VAR . EQUALS doublelinkedlistexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 149
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 157

state 130

    (59) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign .

    $end            reduce using rule 59 (doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN doublelinkedlistassign .)


state 131

    (63) stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR . endexpression
    (76) endexpression -> . PUNTOCOMA

    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 158

state 132

    (65) stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN stackassign .

    $end            reduce using rule 65 (stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN stackassign .)


state 133

    (69) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR . endexpression
    (72) queueassign -> VAR . EQUALS queueexpression endexpression
    (76) endexpression -> . PUNTOCOMA

    EQUALS          shift and go to state 153
    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 159

state 134

    (71) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign .

    $end            reduce using rule 71 (queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN queueassign .)


state 135

    (77) expression -> expression PLUS expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

    PLUS            reduce using rule 77 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 77 (expression -> expression PLUS expression .)
    MOD             reduce using rule 77 (expression -> expression PLUS expression .)
    TIMESTIMES      reduce using rule 77 (expression -> expression PLUS expression .)
    PUNTOCOMA       reduce using rule 77 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 77 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101

  ! TIMES           [ reduce using rule 77 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 77 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 98 ]
  ! MINUS           [ shift and go to state 99 ]
  ! MOD             [ shift and go to state 102 ]
  ! TIMESTIMES      [ shift and go to state 103 ]


state 136

    (78) expression -> expression MINUS expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

    PLUS            reduce using rule 78 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 78 (expression -> expression MINUS expression .)
    MOD             reduce using rule 78 (expression -> expression MINUS expression .)
    TIMESTIMES      reduce using rule 78 (expression -> expression MINUS expression .)
    PUNTOCOMA       reduce using rule 78 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 78 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101

  ! TIMES           [ reduce using rule 78 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 78 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 98 ]
  ! MINUS           [ shift and go to state 99 ]
  ! MOD             [ shift and go to state 102 ]
  ! TIMESTIMES      [ shift and go to state 103 ]


state 137

    (79) expression -> expression TIMES expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

    PLUS            reduce using rule 79 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 79 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 79 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 79 (expression -> expression TIMES expression .)
    MOD             reduce using rule 79 (expression -> expression TIMES expression .)
    TIMESTIMES      reduce using rule 79 (expression -> expression TIMES expression .)
    PUNTOCOMA       reduce using rule 79 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 79 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 98 ]
  ! MINUS           [ shift and go to state 99 ]
  ! TIMES           [ shift and go to state 100 ]
  ! DIVIDE          [ shift and go to state 101 ]
  ! MOD             [ shift and go to state 102 ]
  ! TIMESTIMES      [ shift and go to state 103 ]


state 138

    (80) expression -> expression DIVIDE expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

    PLUS            reduce using rule 80 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 80 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 80 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 80 (expression -> expression DIVIDE expression .)
    MOD             reduce using rule 80 (expression -> expression DIVIDE expression .)
    TIMESTIMES      reduce using rule 80 (expression -> expression DIVIDE expression .)
    PUNTOCOMA       reduce using rule 80 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 80 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 98 ]
  ! MINUS           [ shift and go to state 99 ]
  ! TIMES           [ shift and go to state 100 ]
  ! DIVIDE          [ shift and go to state 101 ]
  ! MOD             [ shift and go to state 102 ]
  ! TIMESTIMES      [ shift and go to state 103 ]


state 139

    (81) expression -> expression MOD expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for TIMESTIMES resolved as shift
    PUNTOCOMA       reduce using rule 81 (expression -> expression MOD expression .)
    RPAREN          reduce using rule 81 (expression -> expression MOD expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MOD             shift and go to state 102
    TIMESTIMES      shift and go to state 103

  ! PLUS            [ reduce using rule 81 (expression -> expression MOD expression .) ]
  ! MINUS           [ reduce using rule 81 (expression -> expression MOD expression .) ]
  ! TIMES           [ reduce using rule 81 (expression -> expression MOD expression .) ]
  ! DIVIDE          [ reduce using rule 81 (expression -> expression MOD expression .) ]
  ! MOD             [ reduce using rule 81 (expression -> expression MOD expression .) ]
  ! TIMESTIMES      [ reduce using rule 81 (expression -> expression MOD expression .) ]


state 140

    (84) expression -> expression TIMESTIMES expression .
    (77) expression -> expression . PLUS expression
    (78) expression -> expression . MINUS expression
    (79) expression -> expression . TIMES expression
    (80) expression -> expression . DIVIDE expression
    (81) expression -> expression . MOD expression
    (84) expression -> expression . TIMESTIMES expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for TIMESTIMES resolved as shift
    PUNTOCOMA       reduce using rule 84 (expression -> expression TIMESTIMES expression .)
    RPAREN          reduce using rule 84 (expression -> expression TIMESTIMES expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MOD             shift and go to state 102
    TIMESTIMES      shift and go to state 103

  ! PLUS            [ reduce using rule 84 (expression -> expression TIMESTIMES expression .) ]
  ! MINUS           [ reduce using rule 84 (expression -> expression TIMESTIMES expression .) ]
  ! TIMES           [ reduce using rule 84 (expression -> expression TIMESTIMES expression .) ]
  ! DIVIDE          [ reduce using rule 84 (expression -> expression TIMESTIMES expression .) ]
  ! MOD             [ reduce using rule 84 (expression -> expression TIMESTIMES expression .) ]
  ! TIMESTIMES      [ reduce using rule 84 (expression -> expression TIMESTIMES expression .) ]


state 141

    (90) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 90 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 90 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 90 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 90 (expression -> LPAREN expression RPAREN .)
    MOD             reduce using rule 90 (expression -> LPAREN expression RPAREN .)
    TIMESTIMES      reduce using rule 90 (expression -> LPAREN expression RPAREN .)
    PUNTOCOMA       reduce using rule 90 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 90 (expression -> LPAREN expression RPAREN .)


state 142

    (38) listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 38 (listdeclaration -> accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression .)


state 143

    (42) listassign -> VAR EQUALS . listexpression endexpression
    (43) listexpression -> . NEW LIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    NEW             shift and go to state 161

    listexpression                 shift and go to state 160

state 144

    (44) arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 44 (arraydeclaration -> accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression .)


state 145

    (48) arrayassign -> VAR EQUALS . arrayexpression endexpression
    (49) arrayexpression -> . NEW ARRAYLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    NEW             shift and go to state 163

    arrayexpression                shift and go to state 162

state 146

    (50) linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 50 (linkedlistdeclaration -> accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression .)


state 147

    (54) linkedlistassign -> VAR EQUALS . linkedlistexpression endexpression
    (55) linkedlistexpression -> . NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    NEW             shift and go to state 165

    linkedlistexpression           shift and go to state 164

state 148

    (56) doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 56 (doublelinkedlistdeclaration -> accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression .)


state 149

    (60) doublelinkedlistassign -> VAR EQUALS . doublelinkedlistexpression endexpression
    (61) doublelinkedlistexpression -> . NEW DOUBLELINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    NEW             shift and go to state 167

    doublelinkedlistexpression     shift and go to state 166

state 150

    (62) stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 62 (stackdeclaration -> accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression .)


state 151

    (66) stackassign -> STRING EQUALS . stackexpression endexpression
    (67) stackexpression -> . NEW STACK LESSTHAN Typet GREATTHAN LPAREN RPAREN

    NEW             shift and go to state 169

    stackexpression                shift and go to state 168

state 152

    (68) queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 68 (queuedeclaration -> accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression .)


state 153

    (72) queueassign -> VAR EQUALS . queueexpression endexpression
    (73) queueexpression -> . NEW QUEUE LESSTHAN Typet GREATTHAN LPAREN RPAREN
    (74) queueexpression -> . NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    NEW             shift and go to state 171

    queueexpression                shift and go to state 170

state 154

    (39) listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 39 (listdeclaration -> accessmodif accessmodif finalstatvar LIST LESSTHAN Type GREATTHAN VAR endexpression .)


state 155

    (45) arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 45 (arraydeclaration -> accessmodif accessmodif finalstatvar ARRAYLIST LESSTHAN Type GREATTHAN VAR endexpression .)


state 156

    (51) linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 51 (linkedlistdeclaration -> accessmodif accessmodif finalstatvar LINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression .)


state 157

    (57) doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 57 (doublelinkedlistdeclaration -> accessmodif accessmodif finalstatvar DOUBLELINKEDLIST LESSTHAN Type GREATTHAN VAR endexpression .)


state 158

    (63) stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 63 (stackdeclaration -> accessmodif accessmodif finalstatvar STACK LESSTHAN Type GREATTHAN VAR endexpression .)


state 159

    (69) queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression .

    $end            reduce using rule 69 (queuedeclaration -> accessmodif accessmodif finalstatvar QUEUE LESSTHAN Type GREATTHAN VAR endexpression .)


state 160

    (42) listassign -> VAR EQUALS listexpression . endexpression
    (76) endexpression -> . PUNTOCOMA

    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 172

state 161

    (43) listexpression -> NEW . LIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    LIST            shift and go to state 173


state 162

    (48) arrayassign -> VAR EQUALS arrayexpression . endexpression
    (76) endexpression -> . PUNTOCOMA

    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 174

state 163

    (49) arrayexpression -> NEW . ARRAYLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    ARRAYLIST       shift and go to state 175


state 164

    (54) linkedlistassign -> VAR EQUALS linkedlistexpression . endexpression
    (76) endexpression -> . PUNTOCOMA

    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 176

state 165

    (55) linkedlistexpression -> NEW . LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    LINKEDLIST      shift and go to state 177


state 166

    (60) doublelinkedlistassign -> VAR EQUALS doublelinkedlistexpression . endexpression
    (76) endexpression -> . PUNTOCOMA

    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 178

state 167

    (61) doublelinkedlistexpression -> NEW . DOUBLELINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    DOUBLELINKEDLIST shift and go to state 179


state 168

    (66) stackassign -> STRING EQUALS stackexpression . endexpression
    (76) endexpression -> . PUNTOCOMA

    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 180

state 169

    (67) stackexpression -> NEW . STACK LESSTHAN Typet GREATTHAN LPAREN RPAREN

    STACK           shift and go to state 181


state 170

    (72) queueassign -> VAR EQUALS queueexpression . endexpression
    (76) endexpression -> . PUNTOCOMA

    PUNTOCOMA       shift and go to state 61

    endexpression                  shift and go to state 182

state 171

    (73) queueexpression -> NEW . QUEUE LESSTHAN Typet GREATTHAN LPAREN RPAREN
    (74) queueexpression -> NEW . LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN

    QUEUE           shift and go to state 183
    LINKEDLIST      shift and go to state 184


state 172

    (42) listassign -> VAR EQUALS listexpression endexpression .

    $end            reduce using rule 42 (listassign -> VAR EQUALS listexpression endexpression .)


state 173

    (43) listexpression -> NEW LIST . LESSTHAN Typet GREATTHAN LPAREN RPAREN

    LESSTHAN        shift and go to state 185


state 174

    (48) arrayassign -> VAR EQUALS arrayexpression endexpression .

    $end            reduce using rule 48 (arrayassign -> VAR EQUALS arrayexpression endexpression .)


state 175

    (49) arrayexpression -> NEW ARRAYLIST . LESSTHAN Typet GREATTHAN LPAREN RPAREN

    LESSTHAN        shift and go to state 186


state 176

    (54) linkedlistassign -> VAR EQUALS linkedlistexpression endexpression .

    $end            reduce using rule 54 (linkedlistassign -> VAR EQUALS linkedlistexpression endexpression .)


state 177

    (55) linkedlistexpression -> NEW LINKEDLIST . LESSTHAN Typet GREATTHAN LPAREN RPAREN

    LESSTHAN        shift and go to state 187


state 178

    (60) doublelinkedlistassign -> VAR EQUALS doublelinkedlistexpression endexpression .

    $end            reduce using rule 60 (doublelinkedlistassign -> VAR EQUALS doublelinkedlistexpression endexpression .)


state 179

    (61) doublelinkedlistexpression -> NEW DOUBLELINKEDLIST . LESSTHAN Typet GREATTHAN LPAREN RPAREN

    LESSTHAN        shift and go to state 188


state 180

    (66) stackassign -> STRING EQUALS stackexpression endexpression .

    $end            reduce using rule 66 (stackassign -> STRING EQUALS stackexpression endexpression .)


state 181

    (67) stackexpression -> NEW STACK . LESSTHAN Typet GREATTHAN LPAREN RPAREN

    LESSTHAN        shift and go to state 189


state 182

    (72) queueassign -> VAR EQUALS queueexpression endexpression .

    $end            reduce using rule 72 (queueassign -> VAR EQUALS queueexpression endexpression .)


state 183

    (73) queueexpression -> NEW QUEUE . LESSTHAN Typet GREATTHAN LPAREN RPAREN

    LESSTHAN        shift and go to state 190


state 184

    (74) queueexpression -> NEW LINKEDLIST . LESSTHAN Typet GREATTHAN LPAREN RPAREN

    LESSTHAN        shift and go to state 191


state 185

    (43) listexpression -> NEW LIST LESSTHAN . Typet GREATTHAN LPAREN RPAREN
    (17) Typet -> . INT
    (18) Typet -> . BOOLEAN
    (19) Typet -> . SHORT
    (20) Typet -> . FLOAT
    (21) Typet -> . LONG
    (22) Typet -> . DOUBLE
    (23) Typet -> . CHAR
    (24) Typet -> . BYTE
    (25) Typet -> . OBJECT
    (26) Typet -> . empty
    (93) empty -> .

    INT             shift and go to state 193
    BOOLEAN         shift and go to state 194
    SHORT           shift and go to state 195
    FLOAT           shift and go to state 196
    LONG            shift and go to state 197
    DOUBLE          shift and go to state 198
    CHAR            shift and go to state 199
    BYTE            shift and go to state 200
    OBJECT          shift and go to state 201
    GREATTHAN       reduce using rule 93 (empty -> .)

    Typet                          shift and go to state 192
    empty                          shift and go to state 202

state 186

    (49) arrayexpression -> NEW ARRAYLIST LESSTHAN . Typet GREATTHAN LPAREN RPAREN
    (17) Typet -> . INT
    (18) Typet -> . BOOLEAN
    (19) Typet -> . SHORT
    (20) Typet -> . FLOAT
    (21) Typet -> . LONG
    (22) Typet -> . DOUBLE
    (23) Typet -> . CHAR
    (24) Typet -> . BYTE
    (25) Typet -> . OBJECT
    (26) Typet -> . empty
    (93) empty -> .

    INT             shift and go to state 193
    BOOLEAN         shift and go to state 194
    SHORT           shift and go to state 195
    FLOAT           shift and go to state 196
    LONG            shift and go to state 197
    DOUBLE          shift and go to state 198
    CHAR            shift and go to state 199
    BYTE            shift and go to state 200
    OBJECT          shift and go to state 201
    GREATTHAN       reduce using rule 93 (empty -> .)

    Typet                          shift and go to state 203
    empty                          shift and go to state 202

state 187

    (55) linkedlistexpression -> NEW LINKEDLIST LESSTHAN . Typet GREATTHAN LPAREN RPAREN
    (17) Typet -> . INT
    (18) Typet -> . BOOLEAN
    (19) Typet -> . SHORT
    (20) Typet -> . FLOAT
    (21) Typet -> . LONG
    (22) Typet -> . DOUBLE
    (23) Typet -> . CHAR
    (24) Typet -> . BYTE
    (25) Typet -> . OBJECT
    (26) Typet -> . empty
    (93) empty -> .

    INT             shift and go to state 193
    BOOLEAN         shift and go to state 194
    SHORT           shift and go to state 195
    FLOAT           shift and go to state 196
    LONG            shift and go to state 197
    DOUBLE          shift and go to state 198
    CHAR            shift and go to state 199
    BYTE            shift and go to state 200
    OBJECT          shift and go to state 201
    GREATTHAN       reduce using rule 93 (empty -> .)

    Typet                          shift and go to state 204
    empty                          shift and go to state 202

state 188

    (61) doublelinkedlistexpression -> NEW DOUBLELINKEDLIST LESSTHAN . Typet GREATTHAN LPAREN RPAREN
    (17) Typet -> . INT
    (18) Typet -> . BOOLEAN
    (19) Typet -> . SHORT
    (20) Typet -> . FLOAT
    (21) Typet -> . LONG
    (22) Typet -> . DOUBLE
    (23) Typet -> . CHAR
    (24) Typet -> . BYTE
    (25) Typet -> . OBJECT
    (26) Typet -> . empty
    (93) empty -> .

    INT             shift and go to state 193
    BOOLEAN         shift and go to state 194
    SHORT           shift and go to state 195
    FLOAT           shift and go to state 196
    LONG            shift and go to state 197
    DOUBLE          shift and go to state 198
    CHAR            shift and go to state 199
    BYTE            shift and go to state 200
    OBJECT          shift and go to state 201
    GREATTHAN       reduce using rule 93 (empty -> .)

    Typet                          shift and go to state 205
    empty                          shift and go to state 202

state 189

    (67) stackexpression -> NEW STACK LESSTHAN . Typet GREATTHAN LPAREN RPAREN
    (17) Typet -> . INT
    (18) Typet -> . BOOLEAN
    (19) Typet -> . SHORT
    (20) Typet -> . FLOAT
    (21) Typet -> . LONG
    (22) Typet -> . DOUBLE
    (23) Typet -> . CHAR
    (24) Typet -> . BYTE
    (25) Typet -> . OBJECT
    (26) Typet -> . empty
    (93) empty -> .

    INT             shift and go to state 193
    BOOLEAN         shift and go to state 194
    SHORT           shift and go to state 195
    FLOAT           shift and go to state 196
    LONG            shift and go to state 197
    DOUBLE          shift and go to state 198
    CHAR            shift and go to state 199
    BYTE            shift and go to state 200
    OBJECT          shift and go to state 201
    GREATTHAN       reduce using rule 93 (empty -> .)

    Typet                          shift and go to state 206
    empty                          shift and go to state 202

state 190

    (73) queueexpression -> NEW QUEUE LESSTHAN . Typet GREATTHAN LPAREN RPAREN
    (17) Typet -> . INT
    (18) Typet -> . BOOLEAN
    (19) Typet -> . SHORT
    (20) Typet -> . FLOAT
    (21) Typet -> . LONG
    (22) Typet -> . DOUBLE
    (23) Typet -> . CHAR
    (24) Typet -> . BYTE
    (25) Typet -> . OBJECT
    (26) Typet -> . empty
    (93) empty -> .

    INT             shift and go to state 193
    BOOLEAN         shift and go to state 194
    SHORT           shift and go to state 195
    FLOAT           shift and go to state 196
    LONG            shift and go to state 197
    DOUBLE          shift and go to state 198
    CHAR            shift and go to state 199
    BYTE            shift and go to state 200
    OBJECT          shift and go to state 201
    GREATTHAN       reduce using rule 93 (empty -> .)

    Typet                          shift and go to state 207
    empty                          shift and go to state 202

state 191

    (74) queueexpression -> NEW LINKEDLIST LESSTHAN . Typet GREATTHAN LPAREN RPAREN
    (17) Typet -> . INT
    (18) Typet -> . BOOLEAN
    (19) Typet -> . SHORT
    (20) Typet -> . FLOAT
    (21) Typet -> . LONG
    (22) Typet -> . DOUBLE
    (23) Typet -> . CHAR
    (24) Typet -> . BYTE
    (25) Typet -> . OBJECT
    (26) Typet -> . empty
    (93) empty -> .

    INT             shift and go to state 193
    BOOLEAN         shift and go to state 194
    SHORT           shift and go to state 195
    FLOAT           shift and go to state 196
    LONG            shift and go to state 197
    DOUBLE          shift and go to state 198
    CHAR            shift and go to state 199
    BYTE            shift and go to state 200
    OBJECT          shift and go to state 201
    GREATTHAN       reduce using rule 93 (empty -> .)

    Typet                          shift and go to state 208
    empty                          shift and go to state 202

state 192

    (43) listexpression -> NEW LIST LESSTHAN Typet . GREATTHAN LPAREN RPAREN

    GREATTHAN       shift and go to state 209


state 193

    (17) Typet -> INT .

    GREATTHAN       reduce using rule 17 (Typet -> INT .)


state 194

    (18) Typet -> BOOLEAN .

    GREATTHAN       reduce using rule 18 (Typet -> BOOLEAN .)


state 195

    (19) Typet -> SHORT .

    GREATTHAN       reduce using rule 19 (Typet -> SHORT .)


state 196

    (20) Typet -> FLOAT .

    GREATTHAN       reduce using rule 20 (Typet -> FLOAT .)


state 197

    (21) Typet -> LONG .

    GREATTHAN       reduce using rule 21 (Typet -> LONG .)


state 198

    (22) Typet -> DOUBLE .

    GREATTHAN       reduce using rule 22 (Typet -> DOUBLE .)


state 199

    (23) Typet -> CHAR .

    GREATTHAN       reduce using rule 23 (Typet -> CHAR .)


state 200

    (24) Typet -> BYTE .

    GREATTHAN       reduce using rule 24 (Typet -> BYTE .)


state 201

    (25) Typet -> OBJECT .

    GREATTHAN       reduce using rule 25 (Typet -> OBJECT .)


state 202

    (26) Typet -> empty .

    GREATTHAN       reduce using rule 26 (Typet -> empty .)


state 203

    (49) arrayexpression -> NEW ARRAYLIST LESSTHAN Typet . GREATTHAN LPAREN RPAREN

    GREATTHAN       shift and go to state 210


state 204

    (55) linkedlistexpression -> NEW LINKEDLIST LESSTHAN Typet . GREATTHAN LPAREN RPAREN

    GREATTHAN       shift and go to state 211


state 205

    (61) doublelinkedlistexpression -> NEW DOUBLELINKEDLIST LESSTHAN Typet . GREATTHAN LPAREN RPAREN

    GREATTHAN       shift and go to state 212


state 206

    (67) stackexpression -> NEW STACK LESSTHAN Typet . GREATTHAN LPAREN RPAREN

    GREATTHAN       shift and go to state 213


state 207

    (73) queueexpression -> NEW QUEUE LESSTHAN Typet . GREATTHAN LPAREN RPAREN

    GREATTHAN       shift and go to state 214


state 208

    (74) queueexpression -> NEW LINKEDLIST LESSTHAN Typet . GREATTHAN LPAREN RPAREN

    GREATTHAN       shift and go to state 215


state 209

    (43) listexpression -> NEW LIST LESSTHAN Typet GREATTHAN . LPAREN RPAREN

    LPAREN          shift and go to state 216


state 210

    (49) arrayexpression -> NEW ARRAYLIST LESSTHAN Typet GREATTHAN . LPAREN RPAREN

    LPAREN          shift and go to state 217


state 211

    (55) linkedlistexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN . LPAREN RPAREN

    LPAREN          shift and go to state 218


state 212

    (61) doublelinkedlistexpression -> NEW DOUBLELINKEDLIST LESSTHAN Typet GREATTHAN . LPAREN RPAREN

    LPAREN          shift and go to state 219


state 213

    (67) stackexpression -> NEW STACK LESSTHAN Typet GREATTHAN . LPAREN RPAREN

    LPAREN          shift and go to state 220


state 214

    (73) queueexpression -> NEW QUEUE LESSTHAN Typet GREATTHAN . LPAREN RPAREN

    LPAREN          shift and go to state 221


state 215

    (74) queueexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN . LPAREN RPAREN

    LPAREN          shift and go to state 222


state 216

    (43) listexpression -> NEW LIST LESSTHAN Typet GREATTHAN LPAREN . RPAREN

    RPAREN          shift and go to state 223


state 217

    (49) arrayexpression -> NEW ARRAYLIST LESSTHAN Typet GREATTHAN LPAREN . RPAREN

    RPAREN          shift and go to state 224


state 218

    (55) linkedlistexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN . RPAREN

    RPAREN          shift and go to state 225


state 219

    (61) doublelinkedlistexpression -> NEW DOUBLELINKEDLIST LESSTHAN Typet GREATTHAN LPAREN . RPAREN

    RPAREN          shift and go to state 226


state 220

    (67) stackexpression -> NEW STACK LESSTHAN Typet GREATTHAN LPAREN . RPAREN

    RPAREN          shift and go to state 227


state 221

    (73) queueexpression -> NEW QUEUE LESSTHAN Typet GREATTHAN LPAREN . RPAREN

    RPAREN          shift and go to state 228


state 222

    (74) queueexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN . RPAREN

    RPAREN          shift and go to state 229


state 223

    (43) listexpression -> NEW LIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .

    PUNTOCOMA       reduce using rule 43 (listexpression -> NEW LIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .)


state 224

    (49) arrayexpression -> NEW ARRAYLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .

    PUNTOCOMA       reduce using rule 49 (arrayexpression -> NEW ARRAYLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .)


state 225

    (55) linkedlistexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .

    PUNTOCOMA       reduce using rule 55 (linkedlistexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .)


state 226

    (61) doublelinkedlistexpression -> NEW DOUBLELINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .

    PUNTOCOMA       reduce using rule 61 (doublelinkedlistexpression -> NEW DOUBLELINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .)


state 227

    (67) stackexpression -> NEW STACK LESSTHAN Typet GREATTHAN LPAREN RPAREN .

    PUNTOCOMA       reduce using rule 67 (stackexpression -> NEW STACK LESSTHAN Typet GREATTHAN LPAREN RPAREN .)


state 228

    (73) queueexpression -> NEW QUEUE LESSTHAN Typet GREATTHAN LPAREN RPAREN .

    PUNTOCOMA       reduce using rule 73 (queueexpression -> NEW QUEUE LESSTHAN Typet GREATTHAN LPAREN RPAREN .)


state 229

    (74) queueexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .

    PUNTOCOMA       reduce using rule 74 (queueexpression -> NEW LINKEDLIST LESSTHAN Typet GREATTHAN LPAREN RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PUBLIC in state 0 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 0 resolved as shift
WARNING: shift/reduce conflict for PROTECTED in state 0 resolved as shift
WARNING: shift/reduce conflict for DEFAULT in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 9 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 9 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 104 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for MOD in state 104 resolved as shift
WARNING: shift/reduce conflict for TIMESTIMES in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for MOD in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMESTIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 106 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for MOD in state 106 resolved as shift
WARNING: shift/reduce conflict for TIMESTIMES in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for MOD in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMESTIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 108 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for MOD in state 108 resolved as shift
WARNING: shift/reduce conflict for TIMESTIMES in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 139 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 139 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 139 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 139 resolved as shift
WARNING: shift/reduce conflict for MOD in state 139 resolved as shift
WARNING: shift/reduce conflict for TIMESTIMES in state 139 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 140 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 140 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 140 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 140 resolved as shift
WARNING: shift/reduce conflict for MOD in state 140 resolved as shift
WARNING: shift/reduce conflict for TIMESTIMES in state 140 resolved as shift
WARNING: reduce/reduce conflict in state 19 resolved using rule (accessmodif -> empty)
WARNING: rejected rule (finalstatvar -> empty) in state 19
